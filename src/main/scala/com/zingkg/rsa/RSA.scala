package com.zingkg.rsa

import scala.util.Random

/**
 * This class implements the RSA cryptographic algorithm. It has helper static functions that
 * assist with math when utilizing the algorithm.
 */
object RSA {
  /**
   * Generates a key based on random data.
   *
   * @return A rsa key from randomly generated primes.
   */
  def generateKey: Key = {
    val primes = SieveEratosthenes.getPrimes(1000)
    var publicPrimePos = randomRange(0, primes.size)
    val privatePrimePos = randomRange(0, primes.size)
    if (primes.size != 1) {
      while (privatePrimePos == publicPrimePos)
        publicPrimePos = randomRange(0, primes.size)
    }

    generateKey(primes(publicPrimePos), primes(privatePrimePos))
  }

  /**
   * Generates a key with inputted random primes.
   *
   * @param publicRandom
   *   The public prime to use when generating the modulus.
   * @param privateRandom
   *   The private prime to use when generating the modulus.
   * @return The key generated by the RSA algorithm.
   */
  def generateKey(publicRandom: Int, privateRandom: Int): Key = {
    val modulus = publicRandom * privateRandom
    val totientModulus = (publicRandom - 1) * (privateRandom - 1)
    val keyCoprime = coprime(totientModulus)
    val keyMultiplicativeInverse = modularMultiplicativeInverse(keyCoprime, totientModulus)

    new Key(modulus, keyCoprime, keyMultiplicativeInverse)
  }

  /**
   * Gets a random number in the range specified.
   *
   * @param minimum The minimum number the random should be.
   * @param maximum The maximum number the random should be.
   * @return The random number in the range.
   */
  private def randomRange(minimum: Int, maximum: Int): Int = {
    val range = maximum - minimum
    new Random().nextInt(range) + minimum
  }

  /**
   * Finds the coprime
   *
   * @param totientModulus The modulus' totient which must be obtained before.
   * @return The coprime
   */
  private def coprime(totientModulus: Int): Int = {
    val totientModPrimes = SieveEratosthenes.getPrimes(totientModulus)
    for(i <- totientModPrimes) {
      if(gcd(i, totientModulus) == 1)
        return i
    }

    0
  }

  /**
   * Finds the modular multiplicative inverse from the coprime and totient modulus.
   *
   * @param coprime The coprime to use.
   * @param totientModulus The totient modulus to use.
   * @return The moduluar multiplicative inverse.
   */
  private def modularMultiplicativeInverse(coprime: Int, totientModulus: Int): Int = {
    val multiplicativeInverses = (0 until totientModulus).filter { int =>
      (int * coprime) % totientModulus == 1
    }
    multiplicativeInverses(0)
  }

  /**
   * Finds the greatest common divisor of two numbers.
   *
   * @param quotient1 The first number.
   * @param quotient2 The second number.
   * @return The greatest common divisor.
   */
  def gcd(quotient1: Int, quotient2: Int): Int = {
    var remainder = quotient1 % quotient2
    var lQuotient1 = quotient1
    var lQuotient2 = quotient2
    while (remainder > 0) {
      lQuotient1 = lQuotient2
      lQuotient2 = remainder
      remainder = lQuotient1 % lQuotient2
    }
    lQuotient2
  }
}
